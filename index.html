<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<title>OpenBird</title>
<link rel="icon" type="image/png" href="/bird.png">
<link rel="stylesheet" href="/style.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
</head>
<body>

<header>
  <div class="logo">
    <img src="/bird.png" alt="OpenBird" class="logo-img">
    <h1>OpenBird</h1>
  </div>
  <div class="header-controls">
    <label for="model-select" style="font-size:.8rem;color:#7f8c8d;">Model:</label>
    <select id="model-select"><option>loading...</option></select>
    <label class="auto-run-toggle">
      <input type="checkbox" id="auto-run-cb">
      <span class="toggle-slider"></span>
      <span class="toggle-label">Auto</span>
    </label>
    <button id="clear-btn">Clear</button>
    <button onclick="location.href='/terminal'" style="color:#27ae60;border-color:#a9dfbf;">Terminal</button>
  </div>
</header>

<div id="chat">
  <div class="empty-state" id="empty">Send a message to start chatting</div>
</div>

<div id="status"></div>

<div id="input-bar">
  <textarea id="input" rows="1" placeholder="Type a message..."></textarea>
  <button id="send-btn">Send</button>
</div>

<script>
const chatEl   = document.getElementById("chat");
const inputEl  = document.getElementById("input");
const sendBtn  = document.getElementById("send-btn");
const clearBtn = document.getElementById("clear-btn");
const modelSel = document.getElementById("model-select");
const statusEl = document.getElementById("status");

let generating = false;
let conversationHistory = [];
let currentSessionId = null;
let currentEventSource = null;
const autoRunCb = document.getElementById("auto-run-cb");

// Persist auto-run preference
autoRunCb.checked = localStorage.getItem("openbird-autorun") === "true";
autoRunCb.addEventListener("change", () => {
  localStorage.setItem("openbird-autorun", autoRunCb.checked);
});

// --- Markdown + math rendering ---
function renderMd(text) {
  // Protect math blocks from marked before parsing
  const blocks = [];
  const push = (display, tex) => {
    blocks.push({ display, tex: tex.trim() });
    return `\x00MATH${blocks.length - 1}\x00`;
  };
  // Display: $$...$$ and \[...\]
  let s = text.replace(/\$\$([\s\S]*?)\$\$/g, (_, m) => push(true, m));
  s = s.replace(/\\\[([\s\S]*?)\\\]/g, (_, m) => push(true, m));
  // Inline: $...$ and \(...\)
  s = s.replace(/\$([^\$\n]+?)\$/g, (_, m) => push(false, m));
  s = s.replace(/\\\((.+?)\\\)/g, (_, m) => push(false, m));

  let html = marked.parse(s);

  // Replace placeholders with rendered KaTeX
  html = html.replace(/\x00MATH(\d+)\x00/g, (_, i) => {
    const { display, tex } = blocks[Number(i)];
    try {
      return katex.renderToString(tex, { displayMode: display, throwOnError: false });
    } catch { return tex; }
  });
  return html;
}

// --- Load models via bird --models ---
async function loadModels() {
  try {
    const res = await fetch("/api/models");
    const data = await res.json();
    if (data.error) throw new Error(data.error);
    modelSel.innerHTML = "";
    data.models.forEach(name => {
      const opt = document.createElement("option");
      opt.value = name;
      opt.textContent = name;
      modelSel.appendChild(opt);
    });
    const saved = localStorage.getItem("openbird-model");
    if (saved && data.models.includes(saved)) modelSel.value = saved;
    statusEl.textContent = `Connected — ${data.models.length} model(s) available`;
  } catch (e) {
    modelSel.innerHTML = "<option>unavailable</option>";
    statusEl.textContent = "Could not connect. Is Ollama running?";
  }
}

// --- Parse response into info text and commands ---
function parseResponse(text) {
  const commands = [];
  let info = text;

  // 1. <cmd>...</cmd> tags (preferred)
  let tagHits = 0;
  info = info.replace(/<cmd>\s*([\s\S]*?)\s*<\/cmd>/gi, (full, raw) => {
    const cmd = normalizeCommand(raw);
    if (cmd) commands.push({ action: cmd });
    tagHits++;
    return "";
  });
  if (tagHits > 0 && commands.length > 0) return { info: info.trim(), commands };

  // 2. CMD: control lines
  const keptLines = [];
  let cmdLineHits = 0;
  for (const line of info.split(/\r?\n/)) {
    const m = line.match(/^\s*CMD:\s*(.*)$/i);
    if (m) {
      const cmd = normalizeCommand(m[1]);
      if (cmd) commands.push({ action: cmd });
      cmdLineHits++;
      continue;
    }
    keptLines.push(line);
  }
  info = keptLines.join("\n");
  if (cmdLineHits > 0 && commands.length > 0) return { info: info.trim(), commands };

  // 3. Markdown ```bash blocks (fallback)
  info = text.replace(/```(?:bash|sh|shell)[ \t]*\n([\s\S]*?)```/gi, (_, code) => {
    const cmd = normalizeCommand(code);
    if (cmd) commands.push({ action: cmd });
    return "";
  }).trim();

  return { info, commands };
}

function normalizeCommand(raw) {
  if (typeof raw !== "string") return "";
  let s = raw.trim();
  if (!s) return "";

  s = s.replace(/^`+|`+$/g, "").trim();
  const lines = s
    .split(/\r?\n/)
    .map((line) => line.trim())
    .filter(Boolean);
  if (lines.length === 0) return "";

  return lines[0].replace(/^\$\s+/, "").trim();
}

// --- Render a chat bubble, returns the body element for streaming ---
function addMessage(role, text) {
  const empty = document.getElementById("empty");
  if (empty) empty.remove();

  const div = document.createElement("div");
  div.className = `message ${role}`;

  const label = document.createElement("div");
  label.className = "role";
  label.textContent = role === "user" ? "you" : "bird";
  div.appendChild(label);

  const body = document.createElement("div");
  body.textContent = text;
  div.appendChild(body);

  let timerEl = null;
  if (role === "assistant") {
    timerEl = document.createElement("div");
    timerEl.className = "timer";
    div.appendChild(timerEl);
  }

  chatEl.appendChild(div);
  chatEl.scrollTop = chatEl.scrollHeight;
  return { container: div, body, timerEl };
}

// --- Send / Stop button handler ---
function onSendBtn() {
  // If agent is running, stop it
  if (currentEventSource) {
    stopServerAgent();
    return;
  }
  send();
}

// --- Send prompt to bird via the server ---
async function send() {
  const text = inputEl.value.trim();
  if (!text || generating) return;

  generating = true;
  inputEl.value = "";
  autoResize();

  addMessage("user", text);

  // Auto-run delegates to server-side agent
  if (autoRunCb.checked) {
    sendBtn.textContent = "Stop";
    sendBtn.classList.add("stop-mode");
    await startServerAgent(text);
    sendBtn.textContent = "Send";
    sendBtn.classList.remove("stop-mode");
  } else {
    sendBtn.disabled = true;
    conversationHistory.push({ role: "user", content: text });
    await streamBirdResponse();
  }

  generating = false;
  sendBtn.disabled = false;
  inputEl.focus();
}

// --- Stream a single response from Bird, render it, return parsed commands ---
async function streamBirdResponse() {
  const { container: msgDiv, body: bodyEl, timerEl } = addMessage("assistant", "");
  statusEl.textContent = "Generating...";

  const startTime = performance.now();
  let timerInterval = setInterval(() => {
    const elapsed = ((performance.now() - startTime) / 1000).toFixed(1);
    timerEl.textContent = `${elapsed}s`;
  }, 100);

  let commands = [];

  try {
    const res = await fetch("/api/chat", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ model: modelSel.value, messages: [...conversationHistory] }),
    });

    const reader = res.body.getReader();
    const decoder = new TextDecoder();
    let full = "";
    let buffer = "";
    let metrics = null;

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      buffer += decoder.decode(value, { stream: true });
      const lines = buffer.split("\n");
      buffer = lines.pop();

      for (const line of lines) {
        if (!line.startsWith("data: ")) continue;
        const json = JSON.parse(line.slice(6));
        if (json.error) throw new Error(json.error);
        if (json.done) {
          metrics = json.metrics || null;
          break;
        }
        if (json.content) {
          full += json.content;
          bodyEl.className = "md-body";
          bodyEl.innerHTML = renderMd(full);
          chatEl.scrollTop = chatEl.scrollHeight;
        }
      }
    }

    conversationHistory.push({ role: "assistant", content: full });

    const parsed = parseResponse(full);
    commands = parsed.commands;
    bodyEl.innerHTML = renderMd(parsed.info);

    for (const cmd of commands) {
      const block = document.createElement("div");
      block.className = "command-block";

      const header = document.createElement("div");
      header.className = "command-header";
      header.textContent = "command";

      const btnGroup = document.createElement("div");
      btnGroup.className = "command-buttons";

      const copyBtn = document.createElement("button");
      copyBtn.className = "command-copy";
      copyBtn.textContent = "copy";
      copyBtn.addEventListener("click", () => {
        navigator.clipboard.writeText(cmd.action);
        copyBtn.textContent = "copied!";
        setTimeout(() => copyBtn.textContent = "copy", 1500);
      });

      const runBtn = document.createElement("button");
      runBtn.className = "command-run";
      runBtn.textContent = "run";
      runBtn.addEventListener("click", async () => {
        generating = true;
        sendBtn.disabled = true;
        await runCommand(cmd.action, block, runBtn);
        // Send command output back to AI as a new turn
        await streamBirdResponse();
        generating = false;
        sendBtn.disabled = false;
      });

      btnGroup.appendChild(copyBtn);
      btnGroup.appendChild(runBtn);
      header.appendChild(btnGroup);

      const cmdBody = document.createElement("div");
      cmdBody.className = "command-body";
      cmdBody.textContent = cmd.action;

      block.appendChild(header);
      block.appendChild(cmdBody);
      msgDiv.insertBefore(block, timerEl);

      // Stash refs for auto-run
      cmd._block = block;
      cmd._runBtn = runBtn;
    }

    clearInterval(timerInterval);
    const totalSec = ((performance.now() - startTime) / 1000).toFixed(1);
    timerEl.textContent = `${totalSec}s`;

    if (metrics) {
      const metricsEl = document.createElement("div");
      metricsEl.className = "metrics";
      const parts = [];
      if (metrics.eval_count != null)
        parts.push(`${metrics.eval_count} tokens`);
      if (metrics.eval_count && metrics.eval_duration)
        parts.push(`${(metrics.eval_count / (metrics.eval_duration / 1e9)).toFixed(1)} tok/s`);
      if (metrics.prompt_eval_count != null)
        parts.push(`${metrics.prompt_eval_count} prompt tokens`);
      if (metrics.prompt_eval_count && metrics.prompt_eval_duration)
        parts.push(`${(metrics.prompt_eval_count / (metrics.prompt_eval_duration / 1e9)).toFixed(1)} prompt tok/s`);
      if (metrics.total_duration)
        parts.push(`${(metrics.total_duration / 1e9).toFixed(2)}s total`);
      if (metrics.load_duration)
        parts.push(`${(metrics.load_duration / 1e9).toFixed(2)}s load`);
      metricsEl.textContent = parts.join(" · ");
      msgDiv.appendChild(metricsEl);
    }

    statusEl.textContent = "";
    chatEl.scrollTop = chatEl.scrollHeight;
  } catch (e) {
    bodyEl.textContent = "Error: " + e.message;
    clearInterval(timerInterval);
    timerEl.textContent = "";
    statusEl.textContent = "";
  }

  return { commands };
}

// --- Server-side agent ---
async function startServerAgent(message) {
  try {
    const body = { model: modelSel.value, message };
    if (currentSessionId) {
      // Continue existing session
      body.sessionId = currentSessionId;
    } else {
      // New session — send full conversation history so the agent has context
      body.history = [...conversationHistory];
    }

    const res = await fetch("/api/agent/start", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body),
    });
    const data = await res.json();
    const sessionId = data.sessionId;
    currentSessionId = sessionId;
    localStorage.setItem("openbird-session", sessionId);

    await listenToAgent(sessionId);

    // Sync conversation history from server so manual mode has full context
    await syncHistoryFromAgent(sessionId);
  } catch (e) {
    statusEl.textContent = "Agent error: " + e.message;
  } finally {
    generating = false;
    sendBtn.disabled = false;
    currentEventSource = null;
  }
}

async function syncHistoryFromAgent(sessionId) {
  if (!sessionId) return;
  try {
    const res = await fetch(`/api/agent/${sessionId}/status`);
    if (!res.ok) return;
    const data = await res.json();
    if (data.messages && data.messages.length > 0) {
      conversationHistory = data.messages;
    }
  } catch {}
}

function listenToAgent(sessionId) {
  return new Promise((resolve) => {
    const events = new EventSource(`/api/agent/${sessionId}/events`);
    currentEventSource = events;

    let currentMsgDiv = null;
    let currentBodyEl = null;
    let currentTimerEl = null;
    let currentPhaseEl = null;
    let aiText = "";
    let currentCmdBlock = null;
    let currentCmdOutput = null;
    let startTime = null;
    let timerInterval = null;
    let agentStartTime = performance.now();
    let maxIter = 20;

    function setPhase(phase, text) {
      if (!currentPhaseEl) return;
      currentPhaseEl.className = `agent-phase phase-${phase}`;
      currentPhaseEl.innerHTML = `<span class="pulse-dot"></span> ${text}`;
    }

    function updateStatusBar(iteration, extra) {
      const elapsed = ((performance.now() - agentStartTime) / 1000).toFixed(0);
      statusEl.innerHTML = `<span class="agent-status-bar"><span class="step-count">Step ${iteration}</span><span>${extra || ""}</span><span class="elapsed">${elapsed}s elapsed</span></span>`;
    }

    events.onmessage = (e) => {
      const event = JSON.parse(e.data);

      switch (event.type) {
        case "step_start":
          // New AI turn — create a new message bubble
          const msg = addMessage("assistant", "");
          currentMsgDiv = msg.container;
          currentBodyEl = msg.body;
          currentTimerEl = msg.timerEl;
          aiText = "";
          currentCmdBlock = null;
          currentCmdOutput = null;
          startTime = performance.now();
          if (timerInterval) clearInterval(timerInterval);
          timerInterval = setInterval(() => {
            if (currentTimerEl) {
              currentTimerEl.textContent = `${((performance.now() - startTime) / 1000).toFixed(1)}s`;
            }
            updateStatusBar(event.iteration, currentCmdBlock ? "executing command" : "thinking");
          }, 100);

          // Step badge
          const badge = document.createElement("div");
          badge.className = "agent-step-badge";
          badge.textContent = `Step ${event.iteration}`;
          currentMsgDiv.insertBefore(badge, currentMsgDiv.firstChild);

          // Phase indicator
          currentPhaseEl = document.createElement("div");
          currentPhaseEl.className = "agent-phase phase-thinking";
          currentPhaseEl.innerHTML = '<span class="pulse-dot"></span> Thinking...';
          currentMsgDiv.insertBefore(currentPhaseEl, currentBodyEl);

          updateStatusBar(event.iteration, "thinking");
          break;

        case "ai_chunk":
          aiText += event.content;
          if (currentBodyEl) {
            currentBodyEl.className = "md-body";
            currentBodyEl.innerHTML = renderMd(aiText);
            chatEl.scrollTop = chatEl.scrollHeight;
          }
          break;

        case "ai_done":
          if (timerInterval) clearInterval(timerInterval);
          if (currentTimerEl && startTime) {
            currentTimerEl.textContent = `${((performance.now() - startTime) / 1000).toFixed(1)}s`;
          }
          // Re-render with explanation only
          if (currentBodyEl) {
            currentBodyEl.innerHTML = renderMd(event.explanation || "");
          }

          if ((event.toolCalls || []).length > 0) {
            setPhase("running", "Executing tools...");
          } else {
            setPhase("done", "Complete");
          }

          // Render tool call blocks
          for (const call of (event.toolCalls || [])) {
            const block = document.createElement("div");
            block.className = "command-block";
            block.dataset.toolName = call.name;
            const header = document.createElement("div");
            header.className = "command-header";
            header.textContent = call.name;
            const cmdBody = document.createElement("div");
            cmdBody.className = "command-body";
            // Display params based on tool type
            if (call.name === "bash") {
              cmdBody.textContent = call.params.command || "";
            } else {
              cmdBody.textContent = JSON.stringify(call.params, null, 2);
            }
            block.appendChild(header);
            block.appendChild(cmdBody);
            if (currentMsgDiv && currentTimerEl) {
              currentMsgDiv.insertBefore(block, currentTimerEl);
            }
          }
          // Show metrics
          if (event.metrics && currentMsgDiv) {
            const metricsEl = document.createElement("div");
            metricsEl.className = "metrics";
            const parts = [];
            const m = event.metrics;
            if (m.eval_count != null) parts.push(`${m.eval_count} tokens`);
            if (m.eval_count && m.eval_duration) parts.push(`${(m.eval_count / (m.eval_duration / 1e9)).toFixed(1)} tok/s`);
            if (m.prompt_eval_count != null) parts.push(`${m.prompt_eval_count} prompt tokens`);
            if (m.total_duration) parts.push(`${(m.total_duration / 1e9).toFixed(2)}s total`);
            metricsEl.textContent = parts.join(" · ");
            currentMsgDiv.appendChild(metricsEl);
          }
          chatEl.scrollTop = chatEl.scrollHeight;
          break;

        case "tool_start": {
          const label = event.name === "bash"
            ? (event.params.command || "").slice(0, 40)
            : event.name;
          updateStatusBar(event.iteration || "?", label + (label.length >= 40 ? "..." : ""));
          // Find the matching block by tool name and mark as executing
          const blocks = currentMsgDiv ? currentMsgDiv.querySelectorAll(`.command-block[data-tool-name="${event.name}"]`) : [];
          currentCmdBlock = blocks.length > 0 ? blocks[blocks.length - 1] : null;
          if (currentCmdBlock && !currentCmdBlock.classList.contains("executing")) {
            currentCmdBlock.classList.add("executing");
            currentCmdOutput = document.createElement("div");
            currentCmdOutput.className = "command-output";
            currentCmdBlock.appendChild(currentCmdOutput);
          }
          break;
        }

        case "tool_output":
          if (currentCmdOutput) {
            if (event.stream === "stderr") {
              const span = document.createElement("span");
              span.className = "stderr";
              span.textContent = event.data;
              currentCmdOutput.appendChild(span);
            } else {
              currentCmdOutput.textContent += event.data;
            }
            chatEl.scrollTop = chatEl.scrollHeight;
          }
          break;

        case "tool_done": {
          if (currentCmdBlock) {
            currentCmdBlock.classList.remove("executing");
            const result = event.result || {};
            const isSuccess = result.exitCode === 0 || (!result.error && result.exitCode == null);
            currentCmdBlock.classList.add(isSuccess ? "cmd-success" : "cmd-failure");
            const hdr = currentCmdBlock.querySelector(".command-header");
            if (hdr) {
              const resultEl = document.createElement("span");
              resultEl.style.marginLeft = "auto";
              resultEl.style.fontWeight = "600";
              if (result.exitCode != null) {
                resultEl.textContent = `exit ${result.exitCode}`;
              } else if (result.error) {
                resultEl.textContent = "error";
              } else {
                resultEl.textContent = "done";
              }
              resultEl.style.color = isSuccess ? "#27ae60" : "#e74c3c";
              hdr.appendChild(resultEl);
            }
            // For non-bash tools without streaming output, show result summary
            if (currentCmdOutput && !currentCmdOutput.textContent && event.name !== "bash") {
              if (result.content != null) {
                currentCmdOutput.textContent = result.content.length > 2000
                  ? result.content.slice(0, 2000) + "\n... (truncated)"
                  : result.content;
              } else if (result.error) {
                currentCmdOutput.textContent = result.error;
              } else if (result.written) {
                currentCmdOutput.textContent = `Wrote ${result.bytes} bytes to ${result.path}`;
              }
            }
            // Add collapse toggle for long output
            if (currentCmdOutput && currentCmdOutput.textContent.length > 300) {
              const toggle = document.createElement("button");
              toggle.className = "command-output-toggle";
              toggle.textContent = "collapse output";
              let collapsed = false;
              toggle.addEventListener("click", () => {
                collapsed = !collapsed;
                currentCmdOutput.classList.toggle("collapsed", collapsed);
                toggle.textContent = collapsed ? "expand output" : "collapse output";
              });
              currentCmdBlock.appendChild(toggle);
            }
          }
          const doneResult = event.result || {};
          const doneSuccess = doneResult.exitCode === 0 || (!doneResult.error && doneResult.exitCode == null);
          setPhase("done", doneSuccess ? `${event.name} succeeded` : `${event.name} failed`);
          currentCmdBlock = null;
          currentCmdOutput = null;
          break;
        }

        case "status":
          if (timerInterval) clearInterval(timerInterval);
          if (event.status === "done" || event.status === "stopped" || event.status === "max_iterations") {
            events.close();
            currentEventSource = null;
            const elapsed = ((performance.now() - agentStartTime) / 1000).toFixed(1);
            if (event.status === "max_iterations") {
              statusEl.textContent = `Agent stopped after max iterations (${elapsed}s)`;
            } else if (event.status === "stopped") {
              statusEl.textContent = `Agent stopped by user (${elapsed}s)`;
            } else {
              statusEl.textContent = `Agent completed (${elapsed}s)`;
            }
            if (event.status === "done") {
              localStorage.removeItem("openbird-session");
              currentSessionId = null;
            }
            resolve();
          }
          break;

        case "error":
          if (timerInterval) clearInterval(timerInterval);
          events.close();
          currentEventSource = null;
          statusEl.textContent = "Agent error: " + event.message;
          resolve();
          break;
      }
    };

    events.onerror = () => {
      if (timerInterval) clearInterval(timerInterval);
      events.close();
      currentEventSource = null;
      statusEl.textContent = "Agent connection lost.";
      resolve();
    };
  });
}

function stopServerAgent() {
  if (currentSessionId) {
    fetch(`/api/agent/${currentSessionId}/stop`, { method: "POST" });
  }
  if (currentEventSource) {
    currentEventSource.close();
    currentEventSource = null;
  }
}

// --- Run a command via /api/run ---
async function runCommand(command, block, runBtn) {
  runBtn.disabled = true;
  runBtn.textContent = "running...";

  // Remove previous output if re-running
  const prev = block.querySelector(".command-output");
  if (prev) prev.remove();

  const output = document.createElement("div");
  output.className = "command-output";
  block.appendChild(output);
  chatEl.scrollTop = chatEl.scrollHeight;

  let stdout = "";
  let stderr = "";
  let exitCode = null;

  try {
    const res = await fetch("/api/run", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ command }),
    });

    const reader = res.body.getReader();
    const decoder = new TextDecoder();
    let buffer = "";

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      buffer += decoder.decode(value, { stream: true });
      const lines = buffer.split("\n");
      buffer = lines.pop();

      for (const line of lines) {
        if (!line.startsWith("data: ")) continue;
        const json = JSON.parse(line.slice(6));

        if (json.type === "stdout") {
          stdout += json.data;
          output.textContent += json.data;
        } else if (json.type === "stderr") {
          stderr += json.data;
          const span = document.createElement("span");
          span.className = "stderr";
          span.textContent = json.data;
          output.appendChild(span);
        } else if (json.type === "exit") {
          exitCode = json.code;
          runBtn.textContent = json.code === 0 ? "ran" : `exit ${json.code}`;
          runBtn.className = json.code === 0 ? "command-run success" : "command-run failure";
        }
        chatEl.scrollTop = chatEl.scrollHeight;
      }
    }
  } catch (e) {
    stderr = e.message;
    output.textContent = "Error: " + e.message;
  }

  // Add command result to conversation context
  let result = `[Executed command: ${command}]\n`;
  if (stdout) result += `stdout:\n${stdout.trimEnd()}\n`;
  if (stderr) result += `stderr:\n${stderr.trimEnd()}\n`;
  if (exitCode !== null) result += `exit code: ${exitCode}`;
  conversationHistory.push({ role: "user", content: result.trim() });

  runBtn.disabled = false;
}

// --- Auto-resize textarea ---
function autoResize() {
  inputEl.style.height = "auto";
  inputEl.style.height = Math.min(inputEl.scrollHeight, 160) + "px";
}

// --- Events ---
sendBtn.addEventListener("click", onSendBtn);
inputEl.addEventListener("keydown", (e) => {
  if (e.key === "Enter" && !e.shiftKey) { e.preventDefault(); onSendBtn(); }
});
inputEl.addEventListener("input", autoResize);
clearBtn.addEventListener("click", () => {
  chatEl.innerHTML = '<div class="empty-state" id="empty">Send a message to start chatting</div>';
  statusEl.textContent = "";
  conversationHistory = [];
  currentSessionId = null;
  localStorage.removeItem("openbird-session");
});

modelSel.addEventListener("change", () => {
  localStorage.setItem("openbird-model", modelSel.value);
});

// --- Init ---
loadModels();
inputEl.focus();

// Reconnect to active agent session on page load
(async function reconnect() {
  const savedSession = localStorage.getItem("openbird-session");
  if (!savedSession) return;
  try {
    const res = await fetch(`/api/agent/${savedSession}/status`);
    if (!res.ok) { localStorage.removeItem("openbird-session"); return; }
    const data = await res.json();
    if (data.status === "running") {
      currentSessionId = savedSession;
      generating = true;
      sendBtn.textContent = "Stop";
      sendBtn.classList.add("stop-mode");
      statusEl.textContent = "Reconnecting to agent...";
      // Rebuild conversation from server state
      for (const msg of data.messages) {
        addMessage(msg.role === "assistant" ? "assistant" : "user", msg.content);
      }
      await listenToAgent(savedSession);
      sendBtn.textContent = "Send";
      sendBtn.classList.remove("stop-mode");
      generating = false;
    } else {
      localStorage.removeItem("openbird-session");
    }
  } catch {
    localStorage.removeItem("openbird-session");
  }
})();
</script>
</body>
</html>
