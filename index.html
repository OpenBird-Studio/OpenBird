<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<title>OpenBird</title>
<link rel="icon" type="image/png" href="/bird.png">
<link rel="stylesheet" href="/style.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
</head>
<body>

<header>
  <div class="logo">
    <img src="/bird.png" alt="OpenBird" class="logo-img">
    <h1>OpenBird</h1>
  </div>
  <div class="header-controls">
    <input id="host-input" type="text" placeholder="Ollama URL" spellcheck="false">
    <button id="connect-btn">Connect</button>
    <button id="disconnect-btn" style="display:none">Disconnect</button>
    <select id="model-select"><option>not connected</option></select>
    <button id="clear-btn">Clear</button>
  </div>
</header>

<div id="chat">
  <div class="empty-state" id="empty">Send a message to start chatting</div>
</div>

<div id="status"></div>

<div id="input-bar">
  <textarea id="input" rows="1" placeholder="Type a message..."></textarea>
  <button id="send-btn">Send</button>
</div>

<script>
const chatEl   = document.getElementById("chat");
const inputEl  = document.getElementById("input");
const sendBtn  = document.getElementById("send-btn");
const clearBtn = document.getElementById("clear-btn");
const modelSel = document.getElementById("model-select");
const hostInput = document.getElementById("host-input");
const connectBtn = document.getElementById("connect-btn");
const disconnectBtn = document.getElementById("disconnect-btn");
const statusEl = document.getElementById("status");

// Restore saved host
const savedHost = localStorage.getItem("openbird-host");
if (savedHost) hostInput.value = savedHost;

function getHost() {
  return hostInput.value.trim().replace(/\/+$/, "") || undefined;
}

let generating = false;
let conversationHistory = [];
let currentSessionId = null;
let currentEventSource = null;

// --- Markdown + math rendering ---
function renderMd(text) {
  // Protect math blocks from marked before parsing
  const blocks = [];
  const push = (display, tex) => {
    blocks.push({ display, tex: tex.trim() });
    return `\x00MATH${blocks.length - 1}\x00`;
  };
  // Display: $$...$$ and \[...\]
  let s = text.replace(/\$\$([\s\S]*?)\$\$/g, (_, m) => push(true, m));
  s = s.replace(/\\\[([\s\S]*?)\\\]/g, (_, m) => push(true, m));
  // Inline: $...$ and \(...\)
  s = s.replace(/\$([^\$\n]+?)\$/g, (_, m) => push(false, m));
  s = s.replace(/\\\((.+?)\\\)/g, (_, m) => push(false, m));

  let html = marked.parse(s);

  // Replace placeholders with rendered KaTeX
  html = html.replace(/\x00MATH(\d+)\x00/g, (_, i) => {
    const { display, tex } = blocks[Number(i)];
    try {
      return katex.renderToString(tex, { displayMode: display, throwOnError: false });
    } catch { return tex; }
  });
  return html;
}

// --- Load models via bird --models ---
async function loadModels() {
  connectBtn.textContent = "...";
  connectBtn.disabled = true;
  connectBtn.classList.remove("connected", "failed");
  try {
    const host = getHost();
    if (host) localStorage.setItem("openbird-host", host);
    else localStorage.removeItem("openbird-host");
    const url = host ? `/api/models?host=${encodeURIComponent(host)}` : "/api/models";
    const res = await fetch(url);
    const data = await res.json();
    if (data.error) throw new Error(data.error);
    modelSel.innerHTML = "";
    data.models.forEach(name => {
      const opt = document.createElement("option");
      opt.value = name;
      opt.textContent = name;
      modelSel.appendChild(opt);
    });
    const saved = localStorage.getItem("openbird-model");
    if (saved && data.models.includes(saved)) modelSel.value = saved;
    connectBtn.style.display = "none";
    disconnectBtn.style.display = "";
    statusEl.textContent = `Connected — ${data.models.length} model(s) available`;
  } catch (e) {
    modelSel.innerHTML = "<option>unavailable</option>";
    connectBtn.textContent = "Failed";
    connectBtn.classList.add("failed");
    connectBtn.style.display = "";
    disconnectBtn.style.display = "none";
    statusEl.textContent = "Could not connect. Is Ollama running?";
  } finally {
    connectBtn.disabled = false;
    if (connectBtn.textContent === "...") connectBtn.textContent = "Connect";
  }
}

// --- Render a chat bubble, returns the body element for streaming ---
function addMessage(role, text) {
  const empty = document.getElementById("empty");
  if (empty) empty.remove();

  const div = document.createElement("div");
  div.className = `message ${role}`;

  const label = document.createElement("div");
  label.className = "role";
  label.textContent = role === "user" ? "you" : "bird";
  div.appendChild(label);

  const body = document.createElement("div");
  body.textContent = text;
  div.appendChild(body);

  let timerEl = null;
  if (role === "assistant") {
    timerEl = document.createElement("div");
    timerEl.className = "timer";
    div.appendChild(timerEl);
  }

  chatEl.appendChild(div);
  chatEl.scrollTop = chatEl.scrollHeight;
  return { container: div, body, timerEl };
}

// --- Send / Stop button handler ---
function onSendBtn() {
  // If agent is running, stop it
  if (currentEventSource) {
    stopServerAgent();
    return;
  }
  send();
}

// --- Send prompt to bird via the server ---
async function send() {
  const text = inputEl.value.trim();
  if (!text || generating) return;

  generating = true;
  inputEl.value = "";
  autoResize();

  addMessage("user", text);

  sendBtn.textContent = "Stop";
  sendBtn.classList.add("stop-mode");
  await startServerAgent(text);
  sendBtn.textContent = "Send";
  sendBtn.classList.remove("stop-mode");

  generating = false;
  sendBtn.disabled = false;
  inputEl.focus();
}

// --- Server-side agent ---
async function startServerAgent(message) {
  try {
    const host = getHost();
    const body = { model: modelSel.value, message, host };
    if (currentSessionId) {
      // Continue existing session
      body.sessionId = currentSessionId;
    } else {
      // New session — send full conversation history so the agent has context
      body.history = [...conversationHistory];
    }

    const res = await fetch("/api/agent/start", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body),
    });
    const data = await res.json();
    const sessionId = data.sessionId;
    currentSessionId = sessionId;
    localStorage.setItem("openbird-session", sessionId);

    await listenToAgent(sessionId);

    await syncHistoryFromAgent(sessionId);
  } catch (e) {
    statusEl.textContent = "Agent error: " + e.message;
  } finally {
    generating = false;
    sendBtn.disabled = false;
    currentEventSource = null;
  }
}

async function syncHistoryFromAgent(sessionId) {
  if (!sessionId) return;
  try {
    const res = await fetch(`/api/agent/${sessionId}/status`);
    if (!res.ok) return;
    const data = await res.json();
    if (data.messages && data.messages.length > 0) {
      conversationHistory = data.messages;
    }
  } catch {}
}

function listenToAgent(sessionId) {
  return new Promise((resolve) => {
    const events = new EventSource(`/api/agent/${sessionId}/events`);
    currentEventSource = events;

    // Single bubble for the entire agent run
    const agentMsg = addMessage("assistant", "");
    const msgDiv = agentMsg.container;
    const timerEl = agentMsg.timerEl;
    // Remove the initial empty body — we'll append step sections instead
    agentMsg.body.remove();

    let phaseEl = null;
    let currentStepBody = null;
    let currentCmdBlock = null;
    let currentCmdOutput = null;
    let stepStartTime = null;
    let timerInterval = null;
    let agentStartTime = performance.now();

    // Insertion point: always insert new content before the timer
    function appendToMsg(el) {
      msgDiv.insertBefore(el, timerEl);
      chatEl.scrollTop = chatEl.scrollHeight;
    }

    function setPhase(phase, text) {
      if (!phaseEl) return;
      phaseEl.className = `agent-phase phase-${phase}`;
      phaseEl.innerHTML = `<span class="pulse-dot"></span> ${text}`;
    }

    function updateStatusBar(iteration, extra) {
      const elapsed = ((performance.now() - agentStartTime) / 1000).toFixed(0);
      statusEl.innerHTML = `<span class="agent-status-bar"><span class="step-count">Step ${iteration}</span><span>${extra || ""}</span><span class="elapsed">${elapsed}s elapsed</span></span>`;
    }

    events.onmessage = (e) => {
      const event = JSON.parse(e.data);

      switch (event.type) {
        case "step_start": {
          currentCmdBlock = null;
          currentCmdOutput = null;
          stepStartTime = performance.now();
          if (timerInterval) clearInterval(timerInterval);
          timerInterval = setInterval(() => {
            const elapsed = ((performance.now() - stepStartTime) / 1000).toFixed(1);
            timerEl.textContent = `${elapsed}s`;
            updateStatusBar(event.iteration, currentCmdBlock ? "executing command" : "thinking");
          }, 100);

          // Step badge
          const badge = document.createElement("div");
          badge.className = "agent-step-badge";
          badge.textContent = `Step ${event.iteration}`;
          appendToMsg(badge);

          // Phase indicator
          phaseEl = document.createElement("div");
          phaseEl.className = "agent-phase phase-thinking";
          phaseEl.innerHTML = '<span class="pulse-dot"></span> Thinking...';
          appendToMsg(phaseEl);

          // Body for this step's AI text
          currentStepBody = document.createElement("div");
          appendToMsg(currentStepBody);

          updateStatusBar(event.iteration, "thinking");
          break;
        }

        case "ai_chunk":
          if (currentStepBody) {
            currentStepBody.className = "md-body";
            currentStepBody.innerHTML = renderMd(event.content ? (currentStepBody._rawText = (currentStepBody._rawText || "") + event.content) : "");
            chatEl.scrollTop = chatEl.scrollHeight;
          }
          break;

        case "ai_done":
          if (timerInterval) clearInterval(timerInterval);
          if (timerEl && stepStartTime) {
            timerEl.textContent = `${((performance.now() - stepStartTime) / 1000).toFixed(1)}s`;
          }
          // Re-render with explanation only (commands stripped)
          if (currentStepBody) {
            const explanation = event.explanation || "";
            if (explanation) {
              currentStepBody.className = "md-body";
              currentStepBody.innerHTML = renderMd(explanation);
            } else {
              // No explanation text — remove empty body
              currentStepBody.remove();
            }
          }

          if ((event.toolCalls || []).length > 0) {
            setPhase("running", "Executing...");
          } else {
            setPhase("done", "Complete");
          }

          // Show metrics
          if (event.metrics && msgDiv) {
            const metricsEl = document.createElement("div");
            metricsEl.className = "metrics";
            const parts = [];
            const m = event.metrics;
            if (m.eval_count != null) parts.push(`${m.eval_count} tokens`);
            if (m.eval_count && m.eval_duration) parts.push(`${(m.eval_count / (m.eval_duration / 1e9)).toFixed(1)} tok/s`);
            if (m.prompt_eval_count != null) parts.push(`${m.prompt_eval_count} prompt tokens`);
            if (m.total_duration) parts.push(`${(m.total_duration / 1e9).toFixed(2)}s total`);
            metricsEl.textContent = parts.join(" · ");
            appendToMsg(metricsEl);
          }

          // Render tool call blocks (after metrics, at bottom of step)
          for (const call of (event.toolCalls || [])) {
            const block = document.createElement("div");
            block.className = "command-block collapsed";
            block.dataset.toolName = call.name;

            const header = document.createElement("div");
            header.className = "command-header";
            // Show the command inline in the header for bash
            const cmdText = call.name === "bash" ? (call.params.command || call.name) : call.name;
            const cmdLabel = document.createElement("span");
            cmdLabel.className = "command-label";
            cmdLabel.textContent = cmdText;
            header.appendChild(cmdLabel);

            const chevron = document.createElement("span");
            chevron.className = "command-chevron";
            chevron.textContent = "\u25B6";
            header.appendChild(chevron);

            // Click header to toggle output visibility
            header.addEventListener("click", () => {
              block.classList.toggle("collapsed");
              chevron.textContent = block.classList.contains("collapsed") ? "\u25B6" : "\u25BC";
            });

            block.appendChild(header);
            appendToMsg(block);
          }
          chatEl.scrollTop = chatEl.scrollHeight;
          break;

        case "tool_start": {
          const label = event.name === "bash"
            ? (event.params.command || "").slice(0, 40)
            : event.name;
          updateStatusBar(event.iteration || "?", label + (label.length >= 40 ? "..." : ""));
          // Find the matching block by tool name
          const blocks = msgDiv.querySelectorAll(`.command-block[data-tool-name="${event.name}"]`);
          currentCmdBlock = blocks.length > 0 ? blocks[blocks.length - 1] : null;
          if (currentCmdBlock && !currentCmdBlock.classList.contains("executing")) {
            currentCmdBlock.classList.add("executing");
            currentCmdOutput = document.createElement("div");
            currentCmdOutput.className = "command-output";
            currentCmdBlock.appendChild(currentCmdOutput);
          }
          break;
        }

        case "tool_output":
          if (currentCmdOutput) {
            if (event.stream === "stderr") {
              const span = document.createElement("span");
              span.className = "stderr";
              span.textContent = event.data;
              currentCmdOutput.appendChild(span);
            } else {
              currentCmdOutput.textContent += event.data;
            }
            chatEl.scrollTop = chatEl.scrollHeight;
          }
          break;

        case "tool_done": {
          if (currentCmdBlock) {
            currentCmdBlock.classList.remove("executing");
            const result = event.result || {};
            const isSuccess = result.exitCode === 0 || (!result.error && result.exitCode == null);
            currentCmdBlock.classList.add(isSuccess ? "cmd-success" : "cmd-failure");
            const hdr = currentCmdBlock.querySelector(".command-header");
            if (hdr) {
              const resultEl = document.createElement("span");
              resultEl.className = "command-result";
              if (result.exitCode != null) {
                resultEl.textContent = `exit ${result.exitCode}`;
              } else if (result.error) {
                resultEl.textContent = "error";
              } else {
                resultEl.textContent = "done";
              }
              resultEl.style.color = isSuccess ? "#27ae60" : "#e74c3c";
              hdr.appendChild(resultEl);
            }
            // For non-bash tools, show result summary in output
            if (currentCmdOutput && !currentCmdOutput.textContent && event.name !== "bash") {
              if (result.content != null) {
                currentCmdOutput.textContent = result.content.length > 2000
                  ? result.content.slice(0, 2000) + "\n... (truncated)"
                  : result.content;
              } else if (result.error) {
                currentCmdOutput.textContent = result.error;
              } else if (result.written) {
                currentCmdOutput.textContent = `Wrote ${result.bytes} bytes to ${result.path}`;
              }
            }
            // If no output at all, remove empty area
            if (currentCmdOutput && !currentCmdOutput.textContent.trim()) {
              currentCmdOutput.remove();
            }
          }
          const doneResult = event.result || {};
          const doneSuccess = doneResult.exitCode === 0 || (!doneResult.error && doneResult.exitCode == null);
          setPhase("done", doneSuccess ? `${event.name} succeeded` : `${event.name} failed`);
          currentCmdBlock = null;
          currentCmdOutput = null;
          break;
        }

        case "status":
          if (timerInterval) clearInterval(timerInterval);
          if (event.status === "done" || event.status === "stopped" || event.status === "max_iterations") {
            events.close();
            currentEventSource = null;
            const elapsed = ((performance.now() - agentStartTime) / 1000).toFixed(1);
            if (event.status === "max_iterations") {
              statusEl.textContent = `Agent stopped after max iterations (${elapsed}s)`;
            } else if (event.status === "stopped") {
              statusEl.textContent = `Agent stopped by user (${elapsed}s)`;
            } else {
              statusEl.textContent = `Agent completed (${elapsed}s)`;
            }
            if (event.status === "done") {
              localStorage.removeItem("openbird-session");
              currentSessionId = null;
            }
            resolve();
          }
          break;

        case "error":
          if (timerInterval) clearInterval(timerInterval);
          events.close();
          currentEventSource = null;
          statusEl.textContent = "Agent error: " + event.message;
          resolve();
          break;
      }
    };

    events.onerror = () => {
      if (timerInterval) clearInterval(timerInterval);
      events.close();
      currentEventSource = null;
      statusEl.textContent = "Agent connection lost.";
      resolve();
    };
  });
}

function stopServerAgent() {
  if (currentSessionId) {
    fetch(`/api/agent/${currentSessionId}/stop`, { method: "POST" });
  }
  if (currentEventSource) {
    currentEventSource.close();
    currentEventSource = null;
  }
}

// --- Auto-resize textarea ---
function autoResize() {
  inputEl.style.height = "auto";
  inputEl.style.height = Math.min(inputEl.scrollHeight, 160) + "px";
}

// --- Events ---
sendBtn.addEventListener("click", onSendBtn);
inputEl.addEventListener("keydown", (e) => {
  if (e.key === "Enter" && !e.shiftKey) { e.preventDefault(); onSendBtn(); }
});
inputEl.addEventListener("input", autoResize);
clearBtn.addEventListener("click", () => {
  chatEl.innerHTML = '<div class="empty-state" id="empty">Send a message to start chatting</div>';
  statusEl.textContent = "";
  conversationHistory = [];
  currentSessionId = null;
  localStorage.removeItem("openbird-session");
});

modelSel.addEventListener("change", () => {
  localStorage.setItem("openbird-model", modelSel.value);
});

connectBtn.addEventListener("click", () => loadModels());
disconnectBtn.addEventListener("click", () => {
  disconnectBtn.style.display = "none";
  connectBtn.style.display = "";
  connectBtn.textContent = "Connect";
  connectBtn.classList.remove("connected", "failed");
  modelSel.innerHTML = "<option>not connected</option>";
  statusEl.textContent = "";
});
hostInput.addEventListener("keydown", (e) => {
  if (e.key === "Enter") { e.preventDefault(); loadModels(); }
});

// --- Init ---
loadModels();
inputEl.focus();

// Reconnect to active agent session on page load
(async function reconnect() {
  const savedSession = localStorage.getItem("openbird-session");
  if (!savedSession) return;
  try {
    const res = await fetch(`/api/agent/${savedSession}/status`);
    if (!res.ok) { localStorage.removeItem("openbird-session"); return; }
    const data = await res.json();
    if (data.status === "running") {
      currentSessionId = savedSession;
      generating = true;
      sendBtn.textContent = "Stop";
      sendBtn.classList.add("stop-mode");
      statusEl.textContent = "Reconnecting to agent...";
      // Rebuild conversation from server state
      for (const msg of data.messages) {
        addMessage(msg.role === "assistant" ? "assistant" : "user", msg.content);
      }
      await listenToAgent(savedSession);
      sendBtn.textContent = "Send";
      sendBtn.classList.remove("stop-mode");
      generating = false;
    } else {
      localStorage.removeItem("openbird-session");
    }
  } catch {
    localStorage.removeItem("openbird-session");
  }
})();
</script>
</body>
</html>
