<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<title>OpenBird</title>
<link rel="icon" type="image/png" href="/bird.png">
<link rel="stylesheet" href="/style.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
</head>
<body>

<header>
  <div class="logo">
    <img src="/bird.png" alt="OpenBird" class="logo-img">
    <h1>OpenBird</h1>
  </div>
  <div class="header-controls">
    <label for="model-select" style="font-size:.8rem;color:#7f8c8d;">Model:</label>
    <select id="model-select"><option>loading...</option></select>
    <label class="auto-run-toggle">
      <input type="checkbox" id="auto-run-cb">
      <span class="toggle-slider"></span>
      <span class="toggle-label">Auto</span>
    </label>
    <button id="clear-btn">Clear</button>
    <button onclick="location.href='/terminal'" style="color:#27ae60;border-color:#a9dfbf;">Terminal</button>
  </div>
</header>

<div id="chat">
  <div class="empty-state" id="empty">Send a message to start chatting</div>
</div>

<div id="status"></div>

<div id="input-bar">
  <textarea id="input" rows="1" placeholder="Type a message..."></textarea>
  <button id="send-btn">Send</button>
</div>

<script>
const chatEl   = document.getElementById("chat");
const inputEl  = document.getElementById("input");
const sendBtn  = document.getElementById("send-btn");
const clearBtn = document.getElementById("clear-btn");
const modelSel = document.getElementById("model-select");
const statusEl = document.getElementById("status");

let generating = false;
let conversationHistory = [];
const autoRunCb = document.getElementById("auto-run-cb");

// Persist auto-run preference
autoRunCb.checked = localStorage.getItem("openbird-autorun") === "true";
autoRunCb.addEventListener("change", () => {
  localStorage.setItem("openbird-autorun", autoRunCb.checked);
});

// --- Markdown + math rendering ---
function renderMd(text) {
  // Protect math blocks from marked before parsing
  const blocks = [];
  const push = (display, tex) => {
    blocks.push({ display, tex: tex.trim() });
    return `\x00MATH${blocks.length - 1}\x00`;
  };
  // Display: $$...$$ and \[...\]
  let s = text.replace(/\$\$([\s\S]*?)\$\$/g, (_, m) => push(true, m));
  s = s.replace(/\\\[([\s\S]*?)\\\]/g, (_, m) => push(true, m));
  // Inline: $...$ and \(...\)
  s = s.replace(/\$([^\$\n]+?)\$/g, (_, m) => push(false, m));
  s = s.replace(/\\\((.+?)\\\)/g, (_, m) => push(false, m));

  let html = marked.parse(s);

  // Replace placeholders with rendered KaTeX
  html = html.replace(/\x00MATH(\d+)\x00/g, (_, i) => {
    const { display, tex } = blocks[Number(i)];
    try {
      return katex.renderToString(tex, { displayMode: display, throwOnError: false });
    } catch { return tex; }
  });
  return html;
}

// --- Load models via bird --models ---
async function loadModels() {
  try {
    const res = await fetch("/api/models");
    const data = await res.json();
    if (data.error) throw new Error(data.error);
    modelSel.innerHTML = "";
    data.models.forEach(name => {
      const opt = document.createElement("option");
      opt.value = name;
      opt.textContent = name;
      modelSel.appendChild(opt);
    });
    const saved = localStorage.getItem("openbird-model");
    if (saved && data.models.includes(saved)) modelSel.value = saved;
    statusEl.textContent = `Connected — ${data.models.length} model(s) available`;
  } catch (e) {
    modelSel.innerHTML = "<option>unavailable</option>";
    statusEl.textContent = "Could not connect. Is Ollama running?";
  }
}

// --- Parse response into info text and commands ---
function parseResponse(text) {
  const commands = [];
  const info = text.replace(/```(?:bash|sh|shell)[ \t]*\n([\s\S]*?)```/gi, (_, code) => {
    commands.push({ action: code.trim().replace(/^\$\s+/gm, "") });
    return "";
  }).trim();

  // Fallback: detect bare commands when AI skips the code block
  if (commands.length === 0 && info) {
    const lines = info.split("\n").map(l => l.trim()).filter(Boolean);
    if (lines.length <= 2) {
      const candidate = lines[lines.length - 1];
      // Short, starts lowercase or with ./ or /, doesn't end with sentence punctuation
      if (candidate.length < 200 && /^[a-z.\/]/.test(candidate) && !/[.!?:,]$/.test(candidate)) {
        commands.push({ action: candidate });
        const remaining = lines.length > 1 ? lines.slice(0, -1).join("\n") : "";
        return { info: remaining, commands };
      }
    }
  }

  return { info, commands };
}

// --- Render a chat bubble, returns the body element for streaming ---
function addMessage(role, text) {
  const empty = document.getElementById("empty");
  if (empty) empty.remove();

  const div = document.createElement("div");
  div.className = `message ${role}`;

  const label = document.createElement("div");
  label.className = "role";
  label.textContent = role === "user" ? "you" : "bird";
  div.appendChild(label);

  const body = document.createElement("div");
  body.textContent = text;
  div.appendChild(body);

  let timerEl = null;
  if (role === "assistant") {
    timerEl = document.createElement("div");
    timerEl.className = "timer";
    div.appendChild(timerEl);
  }

  chatEl.appendChild(div);
  chatEl.scrollTop = chatEl.scrollHeight;
  return { container: div, body, timerEl };
}

// --- Send prompt to bird via the server ---
async function send() {
  const text = inputEl.value.trim();
  if (!text || generating) return;

  generating = true;
  sendBtn.disabled = true;
  inputEl.value = "";
  autoResize();

  addMessage("user", text);
  conversationHistory.push({ role: "user", content: text });

  const { commands } = await streamBirdResponse();

  // Auto-run loop: if auto-run is on and there's a command, run it then ask for next
  if (autoRunCb.checked && commands.length > 0) {
    await autoRunLoop(commands);
  }

  generating = false;
  sendBtn.disabled = false;
  inputEl.focus();
}

// --- Stream a single response from Bird, render it, return parsed commands ---
async function streamBirdResponse() {
  const { container: msgDiv, body: bodyEl, timerEl } = addMessage("assistant", "");
  statusEl.textContent = "Generating...";

  const startTime = performance.now();
  let timerInterval = setInterval(() => {
    const elapsed = ((performance.now() - startTime) / 1000).toFixed(1);
    timerEl.textContent = `${elapsed}s`;
  }, 100);

  let commands = [];

  try {
    const res = await fetch("/api/chat", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ model: modelSel.value, messages: [...conversationHistory] }),
    });

    const reader = res.body.getReader();
    const decoder = new TextDecoder();
    let full = "";
    let buffer = "";
    let metrics = null;

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      buffer += decoder.decode(value, { stream: true });
      const lines = buffer.split("\n");
      buffer = lines.pop();

      for (const line of lines) {
        if (!line.startsWith("data: ")) continue;
        const json = JSON.parse(line.slice(6));
        if (json.error) throw new Error(json.error);
        if (json.done) {
          metrics = json.metrics || null;
          break;
        }
        if (json.content) {
          full += json.content;
          bodyEl.className = "md-body";
          bodyEl.innerHTML = renderMd(full);
          chatEl.scrollTop = chatEl.scrollHeight;
        }
      }
    }

    conversationHistory.push({ role: "assistant", content: full });

    const parsed = parseResponse(full);
    commands = parsed.commands;
    bodyEl.innerHTML = renderMd(parsed.info);

    for (const cmd of commands) {
      const block = document.createElement("div");
      block.className = "command-block";

      const header = document.createElement("div");
      header.className = "command-header";
      header.textContent = "command";

      const btnGroup = document.createElement("div");
      btnGroup.className = "command-buttons";

      const copyBtn = document.createElement("button");
      copyBtn.className = "command-copy";
      copyBtn.textContent = "copy";
      copyBtn.addEventListener("click", () => {
        navigator.clipboard.writeText(cmd.action);
        copyBtn.textContent = "copied!";
        setTimeout(() => copyBtn.textContent = "copy", 1500);
      });

      const runBtn = document.createElement("button");
      runBtn.className = "command-run";
      runBtn.textContent = "run";
      runBtn.addEventListener("click", async () => {
        generating = true;
        sendBtn.disabled = true;
        await runCommand(cmd.action, block, runBtn);
        // Send command output back to AI as a new turn
        const { commands: newCmds } = await streamBirdResponse();
        // If auto-run is on, continue the loop with any new commands
        if (autoRunCb.checked && newCmds.length > 0) {
          await autoRunLoop(newCmds);
        }
        generating = false;
        sendBtn.disabled = false;
      });

      btnGroup.appendChild(copyBtn);
      btnGroup.appendChild(runBtn);
      header.appendChild(btnGroup);

      const cmdBody = document.createElement("div");
      cmdBody.className = "command-body";
      cmdBody.textContent = cmd.action;

      block.appendChild(header);
      block.appendChild(cmdBody);
      msgDiv.insertBefore(block, timerEl);

      // Stash refs for auto-run
      cmd._block = block;
      cmd._runBtn = runBtn;
    }

    clearInterval(timerInterval);
    const totalSec = ((performance.now() - startTime) / 1000).toFixed(1);
    timerEl.textContent = `${totalSec}s`;

    if (metrics) {
      const metricsEl = document.createElement("div");
      metricsEl.className = "metrics";
      const parts = [];
      if (metrics.eval_count != null)
        parts.push(`${metrics.eval_count} tokens`);
      if (metrics.eval_count && metrics.eval_duration)
        parts.push(`${(metrics.eval_count / (metrics.eval_duration / 1e9)).toFixed(1)} tok/s`);
      if (metrics.prompt_eval_count != null)
        parts.push(`${metrics.prompt_eval_count} prompt tokens`);
      if (metrics.prompt_eval_count && metrics.prompt_eval_duration)
        parts.push(`${(metrics.prompt_eval_count / (metrics.prompt_eval_duration / 1e9)).toFixed(1)} prompt tok/s`);
      if (metrics.total_duration)
        parts.push(`${(metrics.total_duration / 1e9).toFixed(2)}s total`);
      if (metrics.load_duration)
        parts.push(`${(metrics.load_duration / 1e9).toFixed(2)}s load`);
      metricsEl.textContent = parts.join(" · ");
      msgDiv.appendChild(metricsEl);
    }

    statusEl.textContent = "";
    chatEl.scrollTop = chatEl.scrollHeight;
  } catch (e) {
    bodyEl.textContent = "Error: " + e.message;
    clearInterval(timerInterval);
    timerEl.textContent = "";
    statusEl.textContent = "";
  }

  return { commands };
}

// --- Auto-run agentic loop ---
async function autoRunLoop(commands) {
  const MAX_ITERATIONS = 20;
  let iteration = 0;
  let currentCommands = commands;

  while (autoRunCb.checked && currentCommands.length > 0 && iteration < MAX_ITERATIONS) {
    iteration++;
    const cmd = currentCommands[0];
    statusEl.textContent = `Auto-running command (step ${iteration})...`;

    // Auto-execute the command
    await runCommand(cmd.action, cmd._block, cmd._runBtn);

    // Check if auto-run was toggled off during execution
    if (!autoRunCb.checked) break;

    // Command result is already in conversationHistory from runCommand()
    // Ask AI for next step
    const result = await streamBirdResponse();
    currentCommands = result.commands;
  }

  if (iteration >= MAX_ITERATIONS) {
    statusEl.textContent = "Auto-run stopped: reached max iterations.";
  }
}

// --- Run a command via /api/run ---
async function runCommand(command, block, runBtn) {
  runBtn.disabled = true;
  runBtn.textContent = "running...";

  // Remove previous output if re-running
  const prev = block.querySelector(".command-output");
  if (prev) prev.remove();

  const output = document.createElement("div");
  output.className = "command-output";
  block.appendChild(output);
  chatEl.scrollTop = chatEl.scrollHeight;

  let stdout = "";
  let stderr = "";
  let exitCode = null;

  try {
    const res = await fetch("/api/run", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ command }),
    });

    const reader = res.body.getReader();
    const decoder = new TextDecoder();
    let buffer = "";

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      buffer += decoder.decode(value, { stream: true });
      const lines = buffer.split("\n");
      buffer = lines.pop();

      for (const line of lines) {
        if (!line.startsWith("data: ")) continue;
        const json = JSON.parse(line.slice(6));

        if (json.type === "stdout") {
          stdout += json.data;
          output.textContent += json.data;
        } else if (json.type === "stderr") {
          stderr += json.data;
          const span = document.createElement("span");
          span.className = "stderr";
          span.textContent = json.data;
          output.appendChild(span);
        } else if (json.type === "exit") {
          exitCode = json.code;
          runBtn.textContent = json.code === 0 ? "ran" : `exit ${json.code}`;
          runBtn.className = json.code === 0 ? "command-run success" : "command-run failure";
        }
        chatEl.scrollTop = chatEl.scrollHeight;
      }
    }
  } catch (e) {
    stderr = e.message;
    output.textContent = "Error: " + e.message;
  }

  // Add command result to conversation context
  let result = `[Executed command: ${command}]\n`;
  if (stdout) result += `stdout:\n${stdout.trimEnd()}\n`;
  if (stderr) result += `stderr:\n${stderr.trimEnd()}\n`;
  if (exitCode !== null) result += `exit code: ${exitCode}`;
  conversationHistory.push({ role: "user", content: result.trim() });

  runBtn.disabled = false;
}

// --- Auto-resize textarea ---
function autoResize() {
  inputEl.style.height = "auto";
  inputEl.style.height = Math.min(inputEl.scrollHeight, 160) + "px";
}

// --- Events ---
sendBtn.addEventListener("click", send);
inputEl.addEventListener("keydown", (e) => {
  if (e.key === "Enter" && !e.shiftKey) { e.preventDefault(); send(); }
});
inputEl.addEventListener("input", autoResize);
clearBtn.addEventListener("click", () => {
  chatEl.innerHTML = '<div class="empty-state" id="empty">Send a message to start chatting</div>';
  statusEl.textContent = "";
  conversationHistory = [];
});

modelSel.addEventListener("change", () => {
  localStorage.setItem("openbird-model", modelSel.value);
});

// --- Init ---
loadModels();
inputEl.focus();
</script>
</body>
</html>
