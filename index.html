<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>OpenBird</title>
<link rel="stylesheet" href="/style.css">
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
</head>
<body>

<header>
  <h1>OpenBird</h1>
  <div class="header-controls">
    <label for="model-select" style="font-size:.8rem;color:#888;">Model:</label>
    <select id="model-select"><option>loading...</option></select>
    <button id="clear-btn">Clear</button>
  </div>
</header>

<div id="chat">
  <div class="empty-state" id="empty">Send a message to start chatting</div>
</div>

<div id="status"></div>

<div id="input-bar">
  <textarea id="input" rows="1" placeholder="Type a message..."></textarea>
  <button id="send-btn">Send</button>
</div>

<script>
const chatEl   = document.getElementById("chat");
const inputEl  = document.getElementById("input");
const sendBtn  = document.getElementById("send-btn");
const clearBtn = document.getElementById("clear-btn");
const modelSel = document.getElementById("model-select");
const statusEl = document.getElementById("status");

let generating = false;

// --- Load models via bird --models ---
async function loadModels() {
  try {
    const res = await fetch("/api/models");
    const data = await res.json();
    if (data.error) throw new Error(data.error);
    modelSel.innerHTML = "";
    data.models.forEach(name => {
      const opt = document.createElement("option");
      opt.value = name;
      opt.textContent = name;
      modelSel.appendChild(opt);
    });
    statusEl.textContent = `Connected â€” ${data.models.length} model(s) available`;
  } catch (e) {
    modelSel.innerHTML = "<option>unavailable</option>";
    statusEl.textContent = "Could not connect. Is Ollama running?";
  }
}

// --- Parse response into info text and optional command ---
function parseResponse(text) {
  const match = text.match(/```(?:\w*)\n([\s\S]*?)```/);
  if (!match) return { info: text.trim(), command: null };
  const command = match[1].trim();
  const info = text.slice(0, match.index) + text.slice(match.index + match[0].length);
  return { info: info.trim(), command };
}

// --- Render a chat bubble, returns the body element for streaming ---
function addMessage(role, text) {
  const empty = document.getElementById("empty");
  if (empty) empty.remove();

  const div = document.createElement("div");
  div.className = `message ${role}`;

  const label = document.createElement("div");
  label.className = "role";
  label.textContent = role === "user" ? "you" : "bird";
  div.appendChild(label);

  const body = document.createElement("div");
  body.textContent = text;
  div.appendChild(body);

  let timerEl = null;
  if (role === "assistant") {
    timerEl = document.createElement("div");
    timerEl.className = "timer";
    div.appendChild(timerEl);
  }

  chatEl.appendChild(div);
  chatEl.scrollTop = chatEl.scrollHeight;
  return { container: div, body, timerEl };
}

// --- Send prompt to bird via the server ---
async function send() {
  const text = inputEl.value.trim();
  if (!text || generating) return;

  generating = true;
  sendBtn.disabled = true;
  inputEl.value = "";
  autoResize();

  addMessage("user", text);
  const { container: msgDiv, body: bodyEl, timerEl } = addMessage("assistant", "");
  statusEl.textContent = "Generating...";

  const startTime = performance.now();
  let timerInterval = setInterval(() => {
    const elapsed = ((performance.now() - startTime) / 1000).toFixed(1);
    timerEl.textContent = `${elapsed}s`;
  }, 100);

  try {
    const res = await fetch("/api/chat", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ model: modelSel.value, prompt: text }),
    });

    const reader = res.body.getReader();
    const decoder = new TextDecoder();
    let full = "";
    let buffer = "";

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      buffer += decoder.decode(value, { stream: true });
      const lines = buffer.split("\n");
      buffer = lines.pop(); // keep incomplete line in buffer

      for (const line of lines) {
        if (!line.startsWith("data: ")) continue;
        const json = JSON.parse(line.slice(6));
        if (json.error) throw new Error(json.error);
        if (json.done) break;
        if (json.content) {
          full += json.content;
          bodyEl.textContent = full;
          chatEl.scrollTop = chatEl.scrollHeight;
        }
      }
    }

    // Strip the leading "[model] " prefix bird prints in one-shot mode
    const cleaned = full.replace(/^\[.*?\]\s*/, "");
    const { info, command } = parseResponse(cleaned);
    bodyEl.className = "md-body";
    bodyEl.innerHTML = marked.parse(info);

    if (command) {
      const block = document.createElement("div");
      block.className = "command-block";

      const header = document.createElement("div");
      header.className = "command-header";
      header.textContent = "command";

      const copyBtn = document.createElement("button");
      copyBtn.className = "command-copy";
      copyBtn.textContent = "copy";
      copyBtn.addEventListener("click", () => {
        navigator.clipboard.writeText(command);
        copyBtn.textContent = "copied!";
        setTimeout(() => copyBtn.textContent = "copy", 1500);
      });
      header.appendChild(copyBtn);

      const cmdBody = document.createElement("div");
      cmdBody.className = "command-body";
      cmdBody.textContent = command;

      block.appendChild(header);
      block.appendChild(cmdBody);
      msgDiv.insertBefore(block, timerEl);
    }

    clearInterval(timerInterval);
    const totalSec = ((performance.now() - startTime) / 1000).toFixed(1);
    timerEl.textContent = `${totalSec}s`;
    statusEl.textContent = "";
    chatEl.scrollTop = chatEl.scrollHeight;
  } catch (e) {
    bodyEl.textContent = "Error: " + e.message;
    clearInterval(timerInterval);
    timerEl.textContent = "";
    statusEl.textContent = "";
  }

  generating = false;
  sendBtn.disabled = false;
  inputEl.focus();
}

// --- Auto-resize textarea ---
function autoResize() {
  inputEl.style.height = "auto";
  inputEl.style.height = Math.min(inputEl.scrollHeight, 160) + "px";
}

// --- Events ---
sendBtn.addEventListener("click", send);
inputEl.addEventListener("keydown", (e) => {
  if (e.key === "Enter" && !e.shiftKey) { e.preventDefault(); send(); }
});
inputEl.addEventListener("input", autoResize);
clearBtn.addEventListener("click", () => {
  chatEl.innerHTML = '<div class="empty-state" id="empty">Send a message to start chatting</div>';
  statusEl.textContent = "";
});

// --- Init ---
loadModels();
inputEl.focus();
</script>
</body>
</html>
