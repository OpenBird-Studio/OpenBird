<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>OpenBird</title>
<link rel="stylesheet" href="/style.css">
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
</head>
<body>

<header>
  <div class="logo">
    <img src="/bird.png" alt="OpenBird" class="logo-img">
    <h1>OpenBird</h1>
  </div>
  <div class="header-controls">
    <label for="model-select" style="font-size:.8rem;color:#7f8c8d;">Model:</label>
    <select id="model-select"><option>loading...</option></select>
    <button id="clear-btn">Clear</button>
  </div>
</header>

<div id="chat">
  <div class="empty-state" id="empty">Send a message to start chatting</div>
</div>

<div id="status"></div>

<div id="input-bar">
  <textarea id="input" rows="1" placeholder="Type a message..."></textarea>
  <button id="send-btn">Send</button>
</div>

<script>
const chatEl   = document.getElementById("chat");
const inputEl  = document.getElementById("input");
const sendBtn  = document.getElementById("send-btn");
const clearBtn = document.getElementById("clear-btn");
const modelSel = document.getElementById("model-select");
const statusEl = document.getElementById("status");

let generating = false;

// --- Load models via bird --models ---
async function loadModels() {
  try {
    const res = await fetch("/api/models");
    const data = await res.json();
    if (data.error) throw new Error(data.error);
    modelSel.innerHTML = "";
    data.models.forEach(name => {
      const opt = document.createElement("option");
      opt.value = name;
      opt.textContent = name;
      modelSel.appendChild(opt);
    });
    const saved = localStorage.getItem("openbird-model");
    if (saved && data.models.includes(saved)) modelSel.value = saved;
    statusEl.textContent = `Connected — ${data.models.length} model(s) available`;
  } catch (e) {
    modelSel.innerHTML = "<option>unavailable</option>";
    statusEl.textContent = "Could not connect. Is Ollama running?";
  }
}

// --- Parse response into info text and commands ---
function parseResponse(text) {
  const commands = [];
  const info = text.replace(/```(?:\w*)\n([\s\S]*?)```/g, (_, code) => {
    commands.push({ action: code.trim() });
    return "";
  }).trim();
  return { info, commands };
}

// --- Render a chat bubble, returns the body element for streaming ---
function addMessage(role, text) {
  const empty = document.getElementById("empty");
  if (empty) empty.remove();

  const div = document.createElement("div");
  div.className = `message ${role}`;

  const label = document.createElement("div");
  label.className = "role";
  label.textContent = role === "user" ? "you" : "bird";
  div.appendChild(label);

  const body = document.createElement("div");
  body.textContent = text;
  div.appendChild(body);

  let timerEl = null;
  if (role === "assistant") {
    timerEl = document.createElement("div");
    timerEl.className = "timer";
    div.appendChild(timerEl);
  }

  chatEl.appendChild(div);
  chatEl.scrollTop = chatEl.scrollHeight;
  return { container: div, body, timerEl };
}

// --- Send prompt to bird via the server ---
async function send() {
  const text = inputEl.value.trim();
  if (!text || generating) return;

  generating = true;
  sendBtn.disabled = true;
  inputEl.value = "";
  autoResize();

  addMessage("user", text);
  const { container: msgDiv, body: bodyEl, timerEl } = addMessage("assistant", "");
  statusEl.textContent = "Generating...";

  const startTime = performance.now();
  let timerInterval = setInterval(() => {
    const elapsed = ((performance.now() - startTime) / 1000).toFixed(1);
    timerEl.textContent = `${elapsed}s`;
  }, 100);

  try {
    const res = await fetch("/api/chat", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ model: modelSel.value, prompt: text }),
    });

    const reader = res.body.getReader();
    const decoder = new TextDecoder();
    let full = "";
    let buffer = "";
    let metrics = null;

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      buffer += decoder.decode(value, { stream: true });
      const lines = buffer.split("\n");
      buffer = lines.pop(); // keep incomplete line in buffer

      for (const line of lines) {
        if (!line.startsWith("data: ")) continue;
        const json = JSON.parse(line.slice(6));
        if (json.error) throw new Error(json.error);
        if (json.done) {
          metrics = json.metrics || null;
          break;
        }
        if (json.content) {
          full += json.content;
          bodyEl.className = "md-body";
          bodyEl.innerHTML = marked.parse(full);
          chatEl.scrollTop = chatEl.scrollHeight;
        }
      }
    }

    const { info, commands } = parseResponse(full);
    bodyEl.innerHTML = marked.parse(info);

    for (const cmd of commands) {
      const block = document.createElement("div");
      block.className = "command-block";

      const header = document.createElement("div");
      header.className = "command-header";
      header.textContent = "command";

      const btnGroup = document.createElement("div");
      btnGroup.className = "command-buttons";

      const copyBtn = document.createElement("button");
      copyBtn.className = "command-copy";
      copyBtn.textContent = "copy";
      copyBtn.addEventListener("click", () => {
        navigator.clipboard.writeText(cmd.action);
        copyBtn.textContent = "copied!";
        setTimeout(() => copyBtn.textContent = "copy", 1500);
      });

      const runBtn = document.createElement("button");
      runBtn.className = "command-run";
      runBtn.textContent = "run";
      runBtn.addEventListener("click", () => runCommand(cmd.action, block, runBtn));

      btnGroup.appendChild(copyBtn);
      btnGroup.appendChild(runBtn);
      header.appendChild(btnGroup);

      const cmdBody = document.createElement("div");
      cmdBody.className = "command-body";
      cmdBody.textContent = cmd.action;

      block.appendChild(header);
      block.appendChild(cmdBody);
      msgDiv.insertBefore(block, timerEl);
    }

    clearInterval(timerInterval);
    const totalSec = ((performance.now() - startTime) / 1000).toFixed(1);
    timerEl.textContent = `${totalSec}s`;

    if (metrics) {
      const metricsEl = document.createElement("div");
      metricsEl.className = "metrics";
      const parts = [];
      if (metrics.eval_count != null)
        parts.push(`${metrics.eval_count} tokens`);
      if (metrics.eval_count && metrics.eval_duration)
        parts.push(`${(metrics.eval_count / (metrics.eval_duration / 1e9)).toFixed(1)} tok/s`);
      if (metrics.prompt_eval_count != null)
        parts.push(`${metrics.prompt_eval_count} prompt tokens`);
      if (metrics.prompt_eval_count && metrics.prompt_eval_duration)
        parts.push(`${(metrics.prompt_eval_count / (metrics.prompt_eval_duration / 1e9)).toFixed(1)} prompt tok/s`);
      if (metrics.total_duration)
        parts.push(`${(metrics.total_duration / 1e9).toFixed(2)}s total`);
      if (metrics.load_duration)
        parts.push(`${(metrics.load_duration / 1e9).toFixed(2)}s load`);
      metricsEl.textContent = parts.join(" · ");
      msgDiv.appendChild(metricsEl);
    }

    statusEl.textContent = "";
    chatEl.scrollTop = chatEl.scrollHeight;
  } catch (e) {
    bodyEl.textContent = "Error: " + e.message;
    clearInterval(timerInterval);
    timerEl.textContent = "";
    statusEl.textContent = "";
  }

  generating = false;
  sendBtn.disabled = false;
  inputEl.focus();
}

// --- Run a command via /api/run ---
async function runCommand(command, block, runBtn) {
  runBtn.disabled = true;
  runBtn.textContent = "running...";

  // Remove previous output if re-running
  const prev = block.querySelector(".command-output");
  if (prev) prev.remove();

  const output = document.createElement("div");
  output.className = "command-output";
  block.appendChild(output);
  chatEl.scrollTop = chatEl.scrollHeight;

  try {
    const res = await fetch("/api/run", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ command }),
    });

    const reader = res.body.getReader();
    const decoder = new TextDecoder();
    let buffer = "";

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      buffer += decoder.decode(value, { stream: true });
      const lines = buffer.split("\n");
      buffer = lines.pop();

      for (const line of lines) {
        if (!line.startsWith("data: ")) continue;
        const json = JSON.parse(line.slice(6));

        if (json.type === "stdout") {
          output.textContent += json.data;
        } else if (json.type === "stderr") {
          const span = document.createElement("span");
          span.className = "stderr";
          span.textContent = json.data;
          output.appendChild(span);
        } else if (json.type === "exit") {
          runBtn.textContent = json.code === 0 ? "ran" : `exit ${json.code}`;
          runBtn.className = json.code === 0 ? "command-run success" : "command-run failure";
        }
        chatEl.scrollTop = chatEl.scrollHeight;
      }
    }
  } catch (e) {
    output.textContent = "Error: " + e.message;
  }

  runBtn.disabled = false;
}

// --- Auto-resize textarea ---
function autoResize() {
  inputEl.style.height = "auto";
  inputEl.style.height = Math.min(inputEl.scrollHeight, 160) + "px";
}

// --- Events ---
sendBtn.addEventListener("click", send);
inputEl.addEventListener("keydown", (e) => {
  if (e.key === "Enter" && !e.shiftKey) { e.preventDefault(); send(); }
});
inputEl.addEventListener("input", autoResize);
clearBtn.addEventListener("click", () => {
  chatEl.innerHTML = '<div class="empty-state" id="empty">Send a message to start chatting</div>';
  statusEl.textContent = "";
});

modelSel.addEventListener("change", () => {
  localStorage.setItem("openbird-model", modelSel.value);
});

// --- Init ---
loadModels();
inputEl.focus();
</script>
</body>
</html>
